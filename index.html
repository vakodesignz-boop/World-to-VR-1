<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <title>Bright Escher Matrix - VR Full Load</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', monospace; user-select: none; }
        
        /* Debug Overlay */
        #start-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #111; z-index: 9999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #00ffcc; text-align: center; padding: 20px;
        }
        #start-btn {
            padding: 20px 50px; font-size: 24px; background: transparent; color: #00ffcc;
            border: 2px solid #00ffcc; border-radius: 50px; cursor: pointer; transition: 0.3s;
            text-transform: uppercase; letter-spacing: 3px; margin-top: 20px; display: none;
        }
        #start-btn:hover { background: #00ffcc; color: black; box-shadow: 0 0 30px #00ffcc; }
        
        /* Debug Log */
        #debug-log {
            font-size: 12px; color: #aaa; margin-bottom: 20px; 
            max-height: 200px; overflow-y: auto; width: 80%; border: 1px solid #333; padding: 10px; text-align: left;
        }
        .log-error { color: #ff5555; }
        .log-success { color: #55ff55; }

        /* Progress Bar */
        #progress-container { width: 300px; height: 10px; background: #333; border-radius: 5px; margin-bottom: 10px; }
        #progress-bar { width: 0%; height: 100%; background: #00ffcc; border-radius: 5px; transition: width 0.3s; }

        /* Breath UI */
        #breathGuide { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; text-align: center; pointer-events: none; z-index: 1500; opacity: 0; transition: opacity 0.5s ease-in-out; text-shadow: 0 0 20px rgba(0, 0, 0, 0.5); }
        #breathAction { font-size: 2rem; font-weight: 300; letter-spacing: 5px; text-transform: uppercase; margin-bottom: 15px; opacity: 0.9; }
        #breathCount { font-size: 3.5rem; font-weight: 100; font-variant-numeric: tabular-nums; min-height: 60px; }

        /* Status Panel */
        #statusPanel {
            position: absolute; top: 20px; left: 20px;
            font-weight: bold; color: #00ffcc; background: rgba(0, 0, 0, 0.7);
            padding: 15px; border-radius: 8px; pointer-events: none;
            z-index: 2000; text-align: left; direction: ltr; min-width: 220px;
        }
        .status-row { display: flex; justify-content: space-between; margin-bottom: 5px; }
        .label { opacity: 0.7; margin-right: 10px; font-size: 12px; }
        .value { color: white; font-size: 14px; }
        .active-state { color: #ff3333; }
    </style>
</head>
<body>

    <div id="start-overlay">
        <h2>SYSTEM INITIALIZATION</h2>
        <div id="progress-container"><div id="progress-bar"></div></div>
        <div id="loading-text">Scanning assets...</div>
        <div id="debug-log"></div>
        <button id="start-btn">ENTER EXPERIENCE</button>
    </div>

    <div id="breathGuide">
        <div id="breathAction">Inhale</div>
        <div id="breathCount"></div>
    </div>

    <div id="statusPanel">
        <div class="status-row"><span class="label">STATE:</span><span class="value" id="uiState">NEUTRAL</span></div>
        <div class="status-row"><span class="label">CHAOS:</span><span class="value" id="uiChaos">0%</span></div>
        <hr style="border-color: rgba(255,255,255,0.1); margin: 5px 0;">
        <div class="status-row"><span class="label">AUDIO:</span><span class="value" id="uiAudioMode">VACUUM</span></div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

        // --- רשימת הקבצים המעודכנת ---
        const CONFIG = {
            assets: {
                mainAudio: './assets/main.mp3',
                heartAudio: './assets/heartbeat.mp3',
                textures: [
                    // Images (1-11)
                    './assets/textures/image1.jpg',
                    './assets/textures/image2.jpg',
                    './assets/textures/image3.jpg',
                    './assets/textures/image4.jpg',
                    './assets/textures/image5.jpg',
                    './assets/textures/image6.jpg',
                    './assets/textures/image7.jpg',
                    './assets/textures/image8.jpg',
                    './assets/textures/image9.jpg',
                    './assets/textures/image10.jpg',
                    './assets/textures/image11.jpg',
                    
                    // Videos (1-11)
                    './assets/textures/video1.mp4',
                    './assets/textures/video2.mp4',
                    './assets/textures/video3.mp4',
                    './assets/textures/video4.mp4',
                    './assets/textures/video5.mp4',
                    './assets/textures/video6.mp4',
                    './assets/textures/video7.mp4',
                    './assets/textures/video8.mp4',
                    './assets/textures/video9.mp4',
                    './assets/textures/video10.mp4',
                    './assets/textures/video11.mp4'
                ]
            },
            world: { size: 500, megaStructureCount: 60, unitSize: 30, density: 0.9 },
            nav: { panSpeed: 0.3, zoomSpeed: 1.5, rotateSpeed: 0.004, damping: 0.05 },
            timing: { multiplier: 1.0, uiCountSeconds: 4, waitBeforePassive: 5.0, totalCycles: 5, ghostDuration: 10.0 },
            physics: { maxDrift: 0.15, baseVacuum: 0.02, acceleration: 0.02 },
            effects: { maxEmissive: 0.9, maxHeavyBlur: 0.1, distortion: 3.0, noise: 0.5, tolerance: 0.15, transitionSpeed: 0.02 },
            chaos: { graceDuration: 3.0, sensitivity: 3.0, unlockThreshold: 0.3, waitBeforeRecovery: 2.5, recoveryDuration: 6.5, maxAttackSpeed: 1.2 }
        };

        const PHASE_DURATION = CONFIG.timing.uiCountSeconds * CONFIG.timing.multiplier;
        const FULL_CYCLE_DURATION = PHASE_DURATION * 4;
        const FOG_START = 50.0;
        const FOG_END = 300.0;

        // --- DEBUG LOGGER ---
        const debugLog = document.getElementById('debug-log');
        const progressBar = document.getElementById('progress-bar');
        const loadingText = document.getElementById('loading-text');
        
        function log(msg, type='neutral') {
            const div = document.createElement('div');
            div.innerText = `> ${msg}`;
            if(type === 'error') div.className = 'log-error';
            if(type === 'success') div.className = 'log-success';
            debugLog.appendChild(div);
            debugLog.scrollTop = debugLog.scrollHeight;
            console.log(msg);
        }

        // --- ASSET MANAGER (ROBUST) ---
        class AssetManager {
            constructor() { this.materials = []; }
            
            loadConfigAssets(onComplete) {
                let loaded = 0; 
                const total = CONFIG.assets.textures.length;
                log(`Starting load of ${total} assets (Images & Videos)...`);

                if (total === 0) {
                    onComplete(); return;
                }

                CONFIG.assets.textures.forEach(url => {
                    const isVideo = url.endsWith('.mp4') || url.endsWith('.webm');
                    const fileName = url.split('/').pop();

                    const updateProgress = () => {
                        loaded++;
                        const pct = Math.floor((loaded / total) * 100);
                        progressBar.style.width = pct + '%';
                        loadingText.innerText = `Loaded ${loaded}/${total}`;
                        
                        if(loaded === total) {
                            log("All assets loaded!", 'success');
                            onComplete();
                        }
                    };

                    if (isVideo) {
                        const video = document.createElement('video');
                        video.src = url; video.loop = true; video.muted = true; 
                        video.playsInline = true; video.crossOrigin = "anonymous";
                        
                        // Fallback: If video takes too long (5s), skip it so app doesn't hang
                        const timeout = setTimeout(() => {
                            log(`TIMEOUT: ${fileName} (too heavy?)`, 'error');
                            updateProgress(); 
                        }, 5000); 

                        video.addEventListener('loadedmetadata', () => {
                            clearTimeout(timeout);
                            const tex = new THREE.VideoTexture(video);
                            tex.colorSpace = THREE.SRGBColorSpace; tex.minFilter = THREE.LinearFilter;
                            const mat = this.createMaterial(tex);
                            mat.userData.imgWidth = video.videoWidth; mat.userData.imgHeight = video.videoHeight;
                            this.materials.push(mat);
                            log(`OK: ${fileName}`, 'success');
                            updateProgress();
                        });
                        
                        video.addEventListener('error', (e) => {
                            clearTimeout(timeout);
                            log(`ERROR: ${fileName} not found/supported`, 'error');
                            updateProgress(); // Count it anyway to avoid stall
                        });
                        
                        video.load();

                    } else {
                        const loader = new THREE.TextureLoader();
                        loader.load(url, (tex) => {
                            tex.colorSpace = THREE.SRGBColorSpace; 
                            const mat = this.createMaterial(tex);
                            if (tex.image) { mat.userData.imgWidth = tex.image.width; mat.userData.imgHeight = tex.image.height; }
                            this.materials.push(mat);
                            log(`OK: ${fileName}`, 'success');
                            updateProgress();
                        }, undefined, (err) => {
                            log(`ERROR: ${fileName}`, 'error');
                            updateProgress(); 
                        });
                    }
                });
            }

            createMaterial(texture) {
                return new THREE.ShaderMaterial({
                    uniforms: {
                        map: { value: texture || new THREE.Texture() }, cameraPos: { value: new THREE.Vector3() },
                        displacementStrength: { value: 7.0 }, displacementRange: { value: 50.0 }, uTime: { value: 0.0 },
                        uClickedUV: { value: new THREE.Vector2(0.5, 0.5) }, uGeoStrength: { value: CONFIG.effects.distortion },
                        uNoiseStrength: { value: CONFIG.effects.noise }, uTolerance: { value: CONFIG.effects.tolerance },
                        uEffectFactor: { value: 0.0 }, uHasClick: { value: false }, uEmissiveStrength: { value: 0.0 },
                        uBlurStrength: { value: 0.0 }, uAgnosiaStrength: { value: 0.0 }, uHeavyBlur: { value: 0.0 }
                    },
                    vertexShader: SHADERS.vertex, fragmentShader: SHADERS.fragment, side: THREE.DoubleSide
                });
            }
            getRandomMaterial() {
                if (this.materials.length === 0) return new THREE.MeshBasicMaterial({ color: 0x333333, wireframe: true });
                return this.materials[Math.floor(Math.random() * this.materials.length)];
            }
        }

        // --- SOUND MANAGER ---
        class SoundManager {
            constructor() {
                this.audioContext = null; this.musicBuffer = null; this.heartbeatBuffer = null;
                this.musicSource = null; this.lowpassNode = null; this.highpassNode = null; this.musicGain = null;
                this.heartbeatSource = null; this.heartbeatGain = null;
                this.noiseSource = null; this.noiseFilter = null; this.noiseGain = null;
                this.baseMainVol = 0.05; this.meditationVol = 0.2; this.maxHeartVol = 1.2;
                this.sirenPhase = 0; this.isPlaying = false;
            }

            async loadAssets() {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                log("Loading Audio...");
                try {
                    const resp1 = await fetch(CONFIG.assets.mainAudio);
                    if(!resp1.ok) throw new Error("Main audio missing");
                    const buf1 = await resp1.arrayBuffer();
                    this.musicBuffer = await this.audioContext.decodeAudioData(buf1);
                    log("Audio: Main OK", 'success');

                    const resp2 = await fetch(CONFIG.assets.heartAudio);
                    if(!resp2.ok) throw new Error("Heart audio missing");
                    const buf2 = await resp2.arrayBuffer();
                    this.heartbeatBuffer = await this.audioContext.decodeAudioData(buf2);
                    log("Audio: Heart OK", 'success');
                } catch(e) {
                    log(`AUDIO ERROR: ${e.message}`, 'error');
                }
            }

            start() {
                if (!this.musicBuffer || !this.heartbeatBuffer) return;
                if (this.isPlaying) return;
                if (this.audioContext.state === 'suspended') this.audioContext.resume();
                
                this.musicSource = this.audioContext.createBufferSource();
                this.musicSource.buffer = this.musicBuffer; this.musicSource.loop = true;
                this.lowpassNode = this.audioContext.createBiquadFilter();
                this.lowpassNode.type = 'lowpass'; this.lowpassNode.frequency.value = 3000;
                this.highpassNode = this.audioContext.createBiquadFilter();
                this.highpassNode.type = 'highpass'; this.highpassNode.frequency.value = 500;
                this.musicGain = this.audioContext.createGain();
                this.musicGain.gain.value = this.baseMainVol;
                this.musicSource.connect(this.lowpassNode); this.lowpassNode.connect(this.highpassNode); this.highpassNode.connect(this.musicGain); this.musicGain.connect(this.audioContext.destination);

                this.heartbeatSource = this.audioContext.createBufferSource();
                this.heartbeatSource.buffer = this.heartbeatBuffer; this.heartbeatSource.loop = true;
                this.heartbeatGain = this.audioContext.createGain(); this.heartbeatGain.gain.value = 0;
                this.heartbeatSource.connect(this.heartbeatGain); this.heartbeatGain.connect(this.audioContext.destination);

                const bufferSize = this.audioContext.sampleRate * 2; 
                const noiseBuffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                const data = noiseBuffer.getChannelData(0); for (let i = 0; i < bufferSize; i++) { data[i] = Math.random() * 2 - 1; }
                this.noiseSource = this.audioContext.createBufferSource(); this.noiseSource.buffer = noiseBuffer; this.noiseSource.loop = true;
                this.noiseFilter = this.audioContext.createBiquadFilter(); this.noiseFilter.type = 'lowpass'; this.noiseFilter.frequency.value = 800; 
                this.noiseGain = this.audioContext.createGain(); this.noiseGain.gain.value = 0; 
                this.noiseSource.connect(this.noiseFilter); this.noiseFilter.connect(this.noiseGain); this.noiseGain.connect(this.audioContext.destination);

                this.musicSource.start(0); this.heartbeatSource.start(0); this.noiseSource.start(0);
                this.isPlaying = true;
            }

            update(chaosLevel) {
                if (!this.isPlaying) return;
                const now = this.audioContext.currentTime;
                const distFromCenter = Math.min(1, Math.abs(chaosLevel));
                const targetHighFreq = 500 - (distFromCenter * 490); 
                this.highpassNode.frequency.setTargetAtTime(Math.max(10, targetHighFreq), now, 0.1);

                if (chaosLevel < 0) { 
                    const depth = Math.abs(chaosLevel);
                    const targetLowFreq = 3000 - (depth * 2700); 
                    this.lowpassNode.frequency.setTargetAtTime(Math.max(200, targetLowFreq), now, 0.1); this.lowpassNode.Q.value = 1; 
                    const targetVol = this.baseMainVol + (depth * (this.meditationVol - this.baseMainVol));
                    this.musicGain.gain.setTargetAtTime(targetVol, now, 0.1);
                    this.musicSource.playbackRate.setTargetAtTime(1.0, now, 0.1);
                    this.heartbeatGain.gain.setTargetAtTime(0, now, 0.1); this.noiseGain.gain.setTargetAtTime(0, now, 0.1);
                } else {
                    let baseFreq = 3000 + (chaosLevel * 17000);
                    const peakSpeed = 0.035; const cycleSpeed = 0.005 + (chaosLevel * (peakSpeed - 0.005)); 
                    this.sirenPhase += cycleSpeed; const wave = Math.sin(this.sirenPhase);
                    const chaosModulation = chaosLevel * wave * 5000;
                    this.lowpassNode.frequency.setTargetAtTime(Math.max(500, baseFreq + chaosModulation), now, 0.1);
                    this.lowpassNode.Q.setTargetAtTime(1 + (chaosLevel * 8), now, 0.1);
                    this.musicGain.gain.setTargetAtTime(this.baseMainVol, now, 0.1);
                    const pitchBend = 1.0 + (wave * chaosLevel * 0.3); this.musicSource.playbackRate.setTargetAtTime(pitchBend, now, 0.05);
                    const hbStart = 0.2; let hbTarget = 0;
                    if (chaosLevel > hbStart) { let relative = (chaosLevel - hbStart) / (1.0 - hbStart); hbTarget = relative * this.maxHeartVol; }
                    this.heartbeatGain.gain.setTargetAtTime(hbTarget, now, 0.1);
                    if (chaosLevel > 0.8 && Math.random() < (0.05 + (chaosLevel-0.8)*0.5)) {
                         this.noiseGain.gain.cancelScheduledValues(now); this.noiseGain.gain.setValueAtTime(0.05, now); this.noiseGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.1);
                    } else { this.noiseGain.gain.setTargetAtTime(0, now, 0.1); }
                }
            }
        }

        // --- SHADERS ---
        const SHADERS = {
            vertex: `uniform float displacementStrength; uniform float displacementRange; uniform vec3 cameraPos; uniform sampler2D map; varying vec2 vUv; varying float vDist; void main() { vUv = uv; vec4 worldPosition = modelMatrix * vec4(position, 1.0); float dist = distance(worldPosition.xyz, cameraPos); vDist = dist; vec4 texColor = texture2D(map, uv); float brightness = texColor.r * 0.3 + texColor.g * 0.59 + texColor.b * 0.11; float effectFactor = max(0.0, (displacementRange - dist) / displacementRange); effectFactor = pow(effectFactor, 2.0); vec3 newPosition = position + normal * brightness * displacementStrength * effectFactor; gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0); }`,
            fragment: `uniform sampler2D map; uniform float uTime; uniform vec2 uClickedUV; uniform float uGeoStrength; uniform float uNoiseStrength; uniform float uEffectFactor; uniform float uTolerance; uniform bool uHasClick; uniform float uEmissiveStrength; uniform float uBlurStrength; uniform float uAgnosiaStrength; uniform float uHeavyBlur; varying vec2 vUv; varying float vDist; vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); } float snoise(vec2 v) { const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439); vec2 i  = floor(v + dot(v, C.yy) ); vec2 x0 = v - i + dot(i, C.xx); vec2 i1; i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0); vec4 x12 = x0.xyxy + C.xxzz; x12.xy -= i1; i = mod(i, 289.0); vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 )); vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0); m = m*m ; m = m*m ; vec3 x = 2.0 * fract(p * C.www) - 1.0; vec3 h = abs(x) - 0.5; vec3 ox = floor(x + 0.5); vec3 a0 = x - ox; m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h ); vec3 g; g.x  = a0.x  * x0.x  + h.x  * x0.y; g.yz = a0.yz * x12.xz + h.yz * x12.yw; return 130.0 * dot(m, g); } vec2 complexWarp(vec2 uv, float strength, float time) { vec2 p = uv - 0.5; float r = length(p); float a = atan(p.y, p.x); float wave = sin(time * 0.2 + r * 4.0) * strength; float newA = a + (wave * r * 1.5); float newR = r * (1.0 + strength * 0.1 * sin(time * 0.15) * r); vec2 newP = vec2(cos(newA), sin(newA)) * newR; return newP + 0.5; } void main() { vec4 originalColor = texture2D(map, vUv); float finalMask = 0.0; if (uHasClick) { vec4 clickedColor = texture2D(map, uClickedUV); float distColor = distance(originalColor.rgb, clickedColor.rgb); finalMask = 1.0 - smoothstep(uTolerance, uTolerance + 0.05, distColor); finalMask *= uEffectFactor; } vec2 fluidUV = vUv; if (finalMask > 0.01) { float n = snoise(vUv * 4.0 + uTime * 0.1); fluidUV = vUv + vec2(n) * uNoiseStrength * 0.15 * finalMask; vec2 warpedUV = complexWarp(fluidUV, uGeoStrength * finalMask, uTime); fluidUV = mix(vUv, warpedUV, finalMask); } if (uAgnosiaStrength > 0.01) { float n = snoise(vUv * 4.0 + uTime * 0.1); vec2 warpedUV = complexWarp(vUv, 2.0, uTime); fluidUV = mix(fluidUV, warpedUV + vec2(n)*0.1, uAgnosiaStrength); } if (uBlurStrength > 0.0001) { float steamNoise = snoise(vUv * 80.0 + uTime * 0.5); fluidUV += vec2(steamNoise) * uBlurStrength; } vec4 distortedColor = texture2D(map, fluidUV); if (uHeavyBlur > 0.0001) { float off = uHeavyBlur * 5.0; vec4 sum = vec4(0.0); sum += texture2D(map, fluidUV) * 0.2; sum += texture2D(map, fluidUV + vec2(off, 0.0)) * 0.1; sum += texture2D(map, fluidUV - vec2(off, 0.0)) * 0.1; sum += texture2D(map, fluidUV + vec2(0.0, off)) * 0.1; sum += texture2D(map, fluidUV - vec2(0.0, off)) * 0.1; sum += texture2D(map, fluidUV + vec2(off, off)) * 0.1; sum += texture2D(map, fluidUV + vec2(-off, -off)) * 0.1; sum += texture2D(map, fluidUV + vec2(off, -off)) * 0.1; sum += texture2D(map, fluidUV + vec2(-off, off)) * 0.1; distortedColor = sum; } if (uEmissiveStrength > 0.001) { float lum = dot(distortedColor.rgb, vec3(0.299, 0.587, 0.114)); vec3 fireDark = vec3(0.8, 0.2, 0.0); vec3 fireLight = vec3(1.0, 0.8, 0.4); vec3 tint = mix(fireDark, fireLight, lum); distortedColor.rgb = mix(distortedColor.rgb, tint, uEmissiveStrength * 0.7); distortedColor.rgb += tint * (uEmissiveStrength * 1.5) * lum; } float fogStart = ${FOG_START.toFixed(1)}; float fogEnd = ${FOG_END.toFixed(1)}; float fogFactor = smoothstep(fogStart, fogEnd, vDist); fogFactor = max(0.0, fogFactor - (uEmissiveStrength * 1.2)); gl_FragColor = mix(distortedColor, vec4(0.0, 0.0, 0.0, 1.0), fogFactor); }`,
            turrellVertex: `varying vec2 vUv; void main(){vUv=uv; gl_Position=projectionMatrix * modelViewMatrix * vec4(position, 1.0);}`,
            turrellFragment: `uniform float uTime; uniform float uOpacity; varying vec2 vUv; void main(){ float t = uTime * 0.15; vec2 uv = vUv * 3.0; float b1 = length(uv - vec2(1.5 + sin(t*0.5) * 0.8, 1.5 + cos(t*0.3) * 0.8)); float b2 = length(uv - vec2(1.5 + cos(t*0.6) * 0.7, 1.5 + sin(t*0.4) * 0.9)); float b3 = length(uv - vec2(1.5 + sin(t*0.2 + 1.0) * 0.5, 1.5 + cos(t*0.5 + 2.0) * 0.5)); float blobs = (1.0 / b1) + (1.0 / b2) + (1.0 / b3); vec3 deepBlue = vec3(0.0, 0.05, 0.2); vec3 mediumBlue = vec3(0.0, 0.2, 0.6); vec3 brightBlue = vec3(0.1, 0.5, 1.0); float mask = smoothstep(2.5, 6.0, blobs); vec3 col = mix(deepBlue, mediumBlue, smoothstep(2.5, 4.0, blobs)); col = mix(col, brightBlue, smoothstep(4.0, 6.0, blobs)); gl_FragColor = vec4(col, uOpacity * mask); }`
        };

        // --- CLASSES (World, State, Breath, Input) ---
        class WorldBuilder {
            constructor(scene, assetManager) {
                this.scene = scene; this.assetManager = assetManager; this.structures = []; this.ghostPlane = null; this.turrellPlane = null;
            }
            build() {
                this.structures.forEach(s => this.scene.remove(s)); this.structures = [];
                const geo = new THREE.PlaneGeometry(CONFIG.world.unitSize, CONFIG.world.unitSize, 32, 32);
                for (let i = 0; i < CONFIG.world.megaStructureCount; i++) {
                    const groupCenterX = (Math.random() - 0.5) * CONFIG.world.size;
                    const groupCenterY = (Math.random() - 0.5) * CONFIG.world.size;
                    const groupCenterZ = (Math.random() - 0.5) * CONFIG.world.size;
                    const rotAxis = Math.floor(Math.random() * 3); const rotAngle = Math.floor(Math.random() * 4) * (Math.PI / 2);
                    for (let x = -2; x <= 2; x++) {
                        for (let y = -2; y <= 2; y++) {
                            for (let z = -2; z <= 2; z++) {
                                if (Math.random() < CONFIG.world.density) continue;
                                const mat = this.assetManager.getRandomMaterial();
                                const m = new THREE.Mesh(geo, mat);
                                if (mat.userData.imgWidth && mat.userData.imgHeight) {
                                    const ar = mat.userData.imgWidth / mat.userData.imgHeight;
                                    if (ar >= 1) m.scale.set(1, 1 / ar, 1); else m.scale.set(ar, 1, 1);
                                }
                                const px = x * CONFIG.world.unitSize; const py = y * CONFIG.world.unitSize; const pz = z * CONFIG.world.unitSize;
                                const t = Math.random(); const localPos = new THREE.Vector3(); const localRot = new THREE.Euler();
                                if (t < 0.33) { localRot.x = Math.PI / 2; localPos.set(px, py - CONFIG.world.unitSize / 2, pz); }
                                else if (t < 0.66) { localRot.y = Math.PI / 2; localPos.set(px - CONFIG.world.unitSize / 2, py, pz); }
                                else { localPos.set(px, py, pz - CONFIG.world.unitSize / 2); }
                                m.position.copy(localPos); m.rotation.copy(localRot);
                                const groupQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(rotAxis===0?1:0, rotAxis===1?1:0, rotAxis===2?1:0), rotAngle);
                                m.position.applyQuaternion(groupQuat); m.quaternion.premultiply(groupQuat);
                                m.position.add(new THREE.Vector3(groupCenterX, groupCenterY, groupCenterZ));
                                const uniqueDrift = new THREE.Vector3((Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2, (Math.random() - 0.5) * 0.5 + 0.5).normalize();
                                m.userData.driftVec = uniqueDrift; m.userData.originalPos = m.position.clone(); m.userData.originalRot = m.quaternion.clone(); 
                                this.scene.add(m); this.structures.push(m);
                            }
                        }
                    }
                }
            }
            buildGhost() {
                const geo = new THREE.PlaneGeometry(CONFIG.world.unitSize * 1.5, CONFIG.world.unitSize * 1.5, 32, 32);
                const mat = this.assetManager.getRandomMaterial().clone(); mat.uniforms.displacementStrength.value = 2.0; mat.uniforms.uEmissiveStrength.value = 1.0; mat.transparent = true; mat.opacity = 0.6; 
                this.ghostPlane = new THREE.Mesh(geo, mat); this.ghostPlane.visible = false; this.ghostPlane.userData.isGhost = true; this.scene.add(this.ghostPlane);
            }
            buildTurrell(camera) {
                const geo = new THREE.PlaneGeometry(2000, 2000);
                const mat = new THREE.ShaderMaterial({ uniforms: { uTime: { value: 0 }, uOpacity: { value: 0.0 } }, vertexShader: SHADERS.turrellVertex, fragmentShader: SHADERS.turrellFragment, transparent: true, depthTest: false, depthWrite: false, blending: THREE.AdditiveBlending });
                this.turrellPlane = new THREE.Mesh(geo, mat); this.turrellPlane.position.set(0, 0, -500); this.turrellPlane.renderOrder = -1;
                camera.add(this.turrellPlane);
            }
        }

        class StateManager {
            constructor() { this.state = 'NEUTRAL'; this.chaosLevel = 0.0; this.unlockedPassive = false; this.gracePool = CONFIG.chaos.graceDuration; this.passiveTimer = CONFIG.timing.waitBeforePassive; this.recoveryTimer = 0; this.wakingTimer = 0; this.activeIdleTimer = 0; this.uiState = document.getElementById('uiState'); this.uiChaos = document.getElementById('uiChaos'); this.uiAudioMode = document.getElementById('uiAudioMode'); }
            update(dt, inputAmount) {
                if (this.state === 'PASSIVE') { if (inputAmount > 0.001) { this.state = 'WAKING'; this.wakingTimer = 0.5; this.passiveTimer = CONFIG.timing.waitBeforePassive; } this.updateUI(); return this.state; }
                if (this.state === 'WAKING') { this.wakingTimer -= dt; if (this.wakingTimer <= 0) { this.state = 'NEUTRAL'; this.gracePool = CONFIG.chaos.graceDuration; } this.updateUI(); return this.state; }
                if (this.state === 'RECOVERING') { if (inputAmount > 0.001) { this.state = 'ACTIVE'; } else { if (this.chaosLevel > 0) { this.chaosLevel -= (dt / CONFIG.chaos.recoveryDuration); if (this.chaosLevel < 0) this.chaosLevel = 0; } if (this.chaosLevel <= 0.001) { this.state = 'NEUTRAL'; this.chaosLevel = 0; this.gracePool = CONFIG.chaos.graceDuration; } } this.updateUI(); return this.state; }
                if (inputAmount > 0.001) { this.passiveTimer = CONFIG.timing.waitBeforePassive; this.activeIdleTimer = 0; if (this.gracePool > 0) { this.gracePool -= dt; } else { this.state = 'ACTIVE'; this.chaosLevel += inputAmount * CONFIG.chaos.sensitivity * dt; this.chaosLevel = Math.min(this.chaosLevel, 1.0); if (this.chaosLevel > CONFIG.chaos.unlockThreshold && !this.unlockedPassive) { this.unlockedPassive = true; } } } else { if (this.state === 'NEUTRAL') { if (this.unlockedPassive && this.chaosLevel <= 0.01) { this.passiveTimer -= dt; if (this.passiveTimer <= 0) { this.state = 'PASSIVE'; } } } else if (this.state === 'ACTIVE') { this.activeIdleTimer += dt; if (this.activeIdleTimer > CONFIG.chaos.waitBeforeRecovery) { this.state = 'RECOVERING'; } } }
                this.updateUI(); return this.state;
            }
            updateUI() { this.uiState.innerText = this.state; this.uiChaos.innerText = Math.floor(this.chaosLevel * 100) + '%'; if (this.state === 'ACTIVE') { this.uiState.className = "value active-state"; this.uiAudioMode.innerText = "ANXIETY"; this.uiAudioMode.style.color = "#ff3333"; } else if (this.state === 'RECOVERING') { this.uiState.className = "value recovering-state"; this.uiAudioMode.innerText = "DECAY"; this.uiAudioMode.style.color = "#ffaa00"; } else if (this.state === 'PASSIVE') { this.uiState.className = "value"; this.uiState.style.color = '#00ccff'; this.uiAudioMode.innerText = "MEDITATION"; this.uiAudioMode.style.color = "#00ccff"; } else { this.uiState.className = "value"; this.uiState.style.color = '#ffffff'; this.uiAudioMode.innerText = "VACUUM"; this.uiAudioMode.style.color = "#ffffff"; } }
        }

        class BreathController {
            constructor() { this.breathEl = document.getElementById('breathGuide'); this.actionEl = document.getElementById('breathAction'); this.countEl = document.getElementById('breathCount'); this.inhalePlanes = []; this.inhaleEffectActive = false; this.ghostActive = false; this.ghostStartTime = 0; this.ghostStartPos = new THREE.Vector3(); this.ghostEndPos = new THREE.Vector3(); this.targetDriftSpeed = 0; this.targetVacuumSpeed = 0; this.targetAgnosia = 0; this.targetHeavyBlur = 0; this.currentEmissive = 0; this.currentBlur = 0; this.attentionInfluence = 0; this.showBreath = false; }
            reset() { this.showBreath = false; this.breathEl.style.opacity = 0; this.targetDriftSpeed = 0; this.targetVacuumSpeed = 0; this.currentEmissive = 0; this.targetAgnosia = 0; this.targetHeavyBlur = 0; this.attentionInfluence = 0; this.inhaleEffectActive = false; this.ghostActive = false; }
            update(timeInPassive, camera, world, attentionSystem) {
                const TIME_BREATH_START = 0.5; const TIME_VOID_START = TIME_BREATH_START + (FULL_CYCLE_DURATION * CONFIG.timing.totalCycles); let cycleFactor = 1.0; let turrellOp = 0;
                if (timeInPassive < TIME_BREATH_START) { this.targetDriftSpeed = 0; this.targetVacuumSpeed = 0; this.showBreath = false; } else if (timeInPassive < TIME_VOID_START) { const breathTime = timeInPassive - TIME_BREATH_START; const cycleIndex = Math.floor(breathTime / FULL_CYCLE_DURATION); const timeInCycle = breathTime % FULL_CYCLE_DURATION; cycleFactor = 1.0 + (cycleIndex * 0.1); if (timeInCycle < PHASE_DURATION) { this.showBreath = true; this.actionEl.innerText = "Inhale"; const displayNum = Math.ceil((PHASE_DURATION - timeInCycle) / CONFIG.timing.multiplier); this.countEl.innerText = displayNum < 4 ? displayNum : ""; this.targetDriftSpeed = 0; this.targetVacuumSpeed = 0; this.attentionInfluence = 0; if (!this.inhaleEffectActive) { this.triggerInhale(camera, world, cycleIndex); this.inhaleEffectActive = true; } const inhaleProgress = timeInCycle / PHASE_DURATION; this.currentEmissive = inhaleProgress * CONFIG.effects.maxEmissive; } else if (timeInCycle < PHASE_DURATION * 2) { this.showBreath = false; this.targetDriftSpeed = 0; this.targetVacuumSpeed = 0; this.attentionInfluence = 0; this.inhaleEffectActive = false; const holdProgress = (timeInCycle - PHASE_DURATION) / PHASE_DURATION; this.currentEmissive = CONFIG.effects.maxEmissive - (holdProgress * (CONFIG.effects.maxEmissive * 0.5)); } else if (timeInCycle < PHASE_DURATION * 3) { this.showBreath = true; this.actionEl.innerText = "Exhale"; const exhaleTime = timeInCycle - (PHASE_DURATION * 2); const displayNum = Math.ceil((PHASE_DURATION - exhaleTime) / CONFIG.timing.multiplier); this.countEl.innerText = displayNum < 4 ? displayNum : ""; this.targetDriftSpeed = CONFIG.physics.maxDrift; this.targetVacuumSpeed = CONFIG.physics.baseVacuum * cycleFactor; this.attentionInfluence = 0; this.currentEmissive += (0.0 - this.currentEmissive) * 0.1; } else { this.showBreath = false; this.targetDriftSpeed = 0; this.targetVacuumSpeed = 0; this.currentEmissive = 0.0; if (!attentionSystem.activeMesh) attentionSystem.trigger(camera, world.structures); this.attentionInfluence = 1; } if (cycleIndex === 1 && !this.ghostActive && timeInCycle > (PHASE_DURATION * 2) + 1.0 && timeInCycle < (PHASE_DURATION * 3)) { this.triggerGhost(camera, world.ghostPlane, performance.now()/1000); } } else { this.targetDriftSpeed = CONFIG.physics.maxDrift * 0.3; this.targetVacuumSpeed = CONFIG.physics.baseVacuum * 0.5; this.showBreath = false; const timeInVoid = timeInPassive - TIME_VOID_START; if (timeInVoid > 3.0) this.targetAgnosia = Math.min((timeInVoid - 5.0) / 5.0, 1.0); if (timeInVoid > 10.0) this.targetHeavyBlur = Math.min((timeInVoid - 10.0) / 8.0, 1.0) * CONFIG.effects.maxHeavyBlur; if (timeInVoid > 5.0) { turrellOp = Math.min((timeInVoid - 5.0) / 15.0, 0.8); } } if (this.showBreath) this.breathEl.style.opacity = 1; else this.breathEl.style.opacity = 0; return { drift: this.targetDriftSpeed, vacuum: this.targetVacuumSpeed, agnosia: this.targetAgnosia, heavyBlur: this.targetHeavyBlur, emissive: this.currentEmissive, blur: this.currentBlur, attention: this.attentionInfluence, turrellOpacity: turrellOp };
            }
            triggerInhale(camera, world, cycleIndex) { this.inhalePlanes = []; const frustum = new THREE.Frustum(); const projScreenMatrix = new THREE.Matrix4(); camera.updateMatrixWorld(); projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse); frustum.setFromProjectionMatrix(projScreenMatrix); let visibleCandidates = []; world.structures.forEach(child => { if (child.isMesh && frustum.containsPoint(child.position)) { const d = child.position.distanceTo(camera.position); if (d < 280) visibleCandidates.push(child); } }); visibleCandidates.sort(() => Math.random() - 0.5); let ratio = Math.max(0, 1.0 - (cycleIndex * 0.2)); const count = Math.ceil(visibleCandidates.length * ratio); this.inhalePlanes = visibleCandidates.slice(0, count); }
            triggerGhost(camera, plane, now) { this.ghostActive = true; this.ghostStartTime = now; plane.visible = true; const tmpDir = new THREE.Vector3(); const right = new THREE.Vector3(); camera.getWorldDirection(tmpDir); right.crossVectors(tmpDir, camera.up).normalize(); const center = camera.position.clone().add(tmpDir.multiplyScalar(60)); const dirType = Math.floor(Math.random() * 4); if (dirType === 0) { this.ghostStartPos.copy(center).addScaledVector(right, -140); this.ghostEndPos.copy(center).addScaledVector(right, 140); } else if (dirType === 1) { this.ghostStartPos.copy(center).addScaledVector(right, 140); this.ghostEndPos.copy(center).addScaledVector(right, -140); } else if (dirType === 2) { this.ghostStartPos.copy(center).addScaledVector(camera.up, 100); this.ghostEndPos.copy(center).addScaledVector(camera.up, -100); } else { this.ghostStartPos.copy(center).addScaledVector(camera.up, -100); this.ghostEndPos.copy(center).addScaledVector(camera.up, 100); } plane.lookAt(camera.position); }
        }

        class InputHandler {
            constructor(dolly, camera, app, renderer) { this.dolly = dolly; this.camera = camera; this.app = app; this.renderer = renderer; this.targetYaw = 0; this.targetPitch = 0; this.targetPosition = new THREE.Vector3(0,0,100); this.targetRoll = 0; this.currentRoll = 0; this.currentYaw = 0; this.currentPitch = 0; this.isMouseDown = false; this.mouse = new THREE.Vector2(); this.lastMouse = {x:0, y:0}; this.startMouse = {x:0, y:0}; this.raycaster = new THREE.Raycaster(); this.inputMagnitude = 0; this.controllers = []; this.setupVRControllers(); this.initListeners(); }
            setupVRControllers() { const controllerModelFactory = new XRControllerModelFactory(); for (let i = 0; i < 2; i++) { const controller = this.renderer.xr.getController(i); controller.addEventListener('selectstart', (e) => this.handleVRClick(e.target)); this.dolly.add(controller); this.controllers.push(controller); const grip = this.renderer.xr.getControllerGrip(i); grip.add(controllerModelFactory.createControllerModel(grip)); this.dolly.add(grip); } }
            handleVRClick(controller) { const tempMatrix = new THREE.Matrix4(); tempMatrix.identity().extractRotation(controller.matrixWorld); this.raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld); this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix); const intersects = this.raycaster.intersectObjects(this.app.world.structures); if (intersects.length > 0) { const intersect = intersects[0]; const mesh = intersect.object; if (!mesh.userData.isUniqueMaterial) { mesh.material = mesh.material.clone(); mesh.userData.isUniqueMaterial = true; } mesh.material.uniforms.uClickedUV.value.copy(intersect.uv); mesh.material.uniforms.uHasClick.value = true; mesh.userData.targetEffectFactor = 1.0; this.inputMagnitude += 0.5; } }
            handleVRInput() { const session = this.renderer.xr.getSession(); if (!session) return; if (session.inputSources) { for (const source of session.inputSources) { if (source.gamepad) { const gp = source.gamepad; const stickX = gp.axes[2] || 0; const stickY = gp.axes[3] || 0; if (source.handedness === 'left') { if (Math.abs(stickX) > 0.1 || Math.abs(stickY) > 0.1) { const rotMatrix = new THREE.Matrix4().makeRotationFromEuler(new THREE.Euler(0, this.targetYaw, 0, 'YXZ')); const forward = new THREE.Vector3(0, 0, -1).applyMatrix4(rotMatrix); const right = new THREE.Vector3(1, 0, 0).applyMatrix4(rotMatrix); this.targetPosition.addScaledVector(forward, -stickY * CONFIG.nav.zoomSpeed * 2); this.targetPosition.addScaledVector(right, stickX * CONFIG.nav.panSpeed * 2); } } if (source.handedness === 'right') { if (Math.abs(stickX) > 0.1 || Math.abs(stickY) > 0.1) { this.targetYaw -= stickX * CONFIG.nav.rotateSpeed * 10; const movement = Math.hypot(stickX, stickY); this.inputMagnitude += movement * 0.02; } } } } } }
            initListeners() { document.addEventListener('wheel', (e) => { e.preventDefault(); this.inputMagnitude += 0.1; this.onScroll(e); }, { passive: false }); document.addEventListener('mousedown', (e) => { if (e.target.id.includes('VRButton') || e.target.id.includes('start')) return; e.preventDefault(); this.inputMagnitude += 0.1; this.isMouseDown = true; this.startMouse = {x: e.clientX, y: e.clientY}; this.lastMouse = {x: e.clientX, y: e.clientY}; }); document.addEventListener('mouseup', (e) => { this.isMouseDown = false; const dist = Math.hypot(e.clientX - this.startMouse.x, e.clientY - this.startMouse.y); if (dist < 5) this.handleClick(e); }); document.addEventListener('mousemove', (e) => { if (!this.isMouseDown) return; const dx = e.clientX - this.lastMouse.x; const dy = e.clientY - this.lastMouse.y; this.lastMouse = {x: e.clientX, y: e.clientY}; this.inputMagnitude += Math.hypot(dx, dy) * 0.005; this.targetYaw += dx * CONFIG.nav.rotateSpeed; this.targetPitch += dy * CONFIG.nav.rotateSpeed; this.targetPitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.targetPitch)); }); }
            onScroll(e) { const z = e.ctrlKey || e.metaKey; const rotMatrix = new THREE.Matrix4().makeRotationFromEuler(new THREE.Euler(this.targetPitch, this.targetYaw, 0, 'YXZ')); const forward = new THREE.Vector3(0,0,-1).applyMatrix4(rotMatrix); if (z) { this.targetPosition.addScaledVector(forward, -Math.sign(e.deltaY) * CONFIG.nav.zoomSpeed * 5); } }
            handleClick(event) { this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1; this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1; this.raycaster.setFromCamera(this.mouse, this.camera); const intersects = this.raycaster.intersectObjects(this.app.world.structures); if (intersects.length > 0) { const intersect = intersects[0]; const mesh = intersect.object; if (!mesh.userData.isUniqueMaterial) { mesh.material = mesh.material.clone(); mesh.userData.isUniqueMaterial = true; } mesh.material.uniforms.uClickedUV.value.copy(intersect.uv); mesh.material.uniforms.uHasClick.value = true; mesh.userData.targetEffectFactor = 1.0; } }
            updateCamera(chaosLevel, now, state, timeInPassive) { const isVR = this.renderer.xr.isPresenting; const targetObj = isVR ? this.dolly : this.camera; if (isVR) this.handleVRInput(); const rotDamping = 0.05; if (state === 'PASSIVE') { const rampDuration = FULL_CYCLE_DURATION * 3.0; const rampUp = Math.min(timeInPassive / rampDuration, 1.0); const smoothFactor = rampUp * rampUp * (3 - 2 * rampUp); this.targetYaw += (Math.sin(now * 0.2) + Math.cos(now * 0.15)) * 0.0008 * smoothFactor; const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(targetObj.quaternion); this.targetPosition.addScaledVector(forward, 0.05 * smoothFactor); } if (state !== 'PASSIVE' && chaosLevel > 0.0) { const wanderStrength = chaosLevel; const panX = Math.sin(now * 0.8) * wanderStrength * 1.5 + Math.cos(now * 2.5) * wanderStrength * 0.5; const panY = Math.cos(now * 0.7) * wanderStrength * 1.2; this.targetYaw += panX * 0.02; if (!isVR) this.targetPitch += panY * 0.02; const zoomDrift = Math.sin(now * 0.3) * wanderStrength * 0.5; const forward = new THREE.Vector3(0,0,-1).applyQuaternion(targetObj.quaternion); this.targetPosition.addScaledVector(forward, zoomDrift); } if (chaosLevel > 0.8) { const panicProgress = (chaosLevel - 0.8) / 0.2; const intensity = Math.pow(panicProgress, 2) * 2.0; const shakeX = (Math.random() - 0.5) * intensity * 5.0; const shakeY = (Math.random() - 0.5) * intensity * 5.0; const shakeZ = (Math.random() - 0.5) * intensity * 5.0; this.targetPosition.add(new THREE.Vector3(shakeX, shakeY, shakeZ)); this.targetYaw += (Math.random() - 0.5) * intensity * 0.1; if(!isVR) this.targetPitch += (Math.random() - 0.5) * intensity * 0.1; this.targetRoll = (Math.random() - 0.5) * intensity * 0.2; } this.currentYaw += (this.targetYaw - this.currentYaw) * rotDamping; this.currentPitch += (this.targetPitch - this.currentPitch) * rotDamping; targetObj.rotation.set(this.currentPitch, this.currentYaw, 0, 'YXZ'); targetObj.position.x += (this.targetPosition.x - targetObj.position.x) * CONFIG.nav.damping; targetObj.position.y += (this.targetPosition.y - targetObj.position.y) * CONFIG.nav.damping; targetObj.position.z += (this.targetPosition.z - targetObj.position.z) * CONFIG.nav.damping; }
            getAndResetInput() { const val = this.inputMagnitude; this.inputMagnitude = 0; return val; }
        }

        const startTime = Date.now();

        class App {
            constructor() {
                this.scene = new THREE.Scene(); this.scene.background = new THREE.Color(0x000000); this.scene.fog = new THREE.Fog(0x000000, FOG_START, FOG_END);
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.dolly = new THREE.Group(); this.dolly.add(this.camera); this.scene.add(this.dolly);
                this.renderer = new THREE.WebGLRenderer({ antialias: true }); this.renderer.setSize(window.innerWidth, window.innerHeight); this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); this.renderer.xr.enabled = true; 
                document.body.appendChild(this.renderer.domElement);
                document.body.appendChild(VRButton.createButton(this.renderer));
                this.assetManager = new AssetManager(); this.world = new WorldBuilder(this.scene, this.assetManager); this.input = new InputHandler(this.dolly, this.camera, this, this.renderer); this.stateManager = new StateManager(); this.breathSystem = new BreathController(); this.soundManager = new SoundManager();
                this.currentDriftSpeed = 0; this.currentVacuumSpeed = 0; this.accumulatedScatter = 0; this.currentAgnosia = 0; this.currentHeavyBlur = 0; this.attentionInfluence = 0; this.activeMesh = null; this.dummyObj = new THREE.Object3D(); this.passiveStartTime = 0;
                
                const startBtn = document.getElementById('start-btn');
                const overlay = document.getElementById('start-overlay');
                
                this.assetManager.loadConfigAssets(() => {
                    startBtn.style.display = "inline-block";
                    startBtn.disabled = false;
                    startBtn.addEventListener('click', async () => {
                         overlay.style.opacity = 0; setTimeout(() => overlay.remove(), 500);
                         await this.soundManager.loadAssets();
                         this.init(); this.soundManager.start();
                    });
                });
            }
            init() {
                this.dolly.position.set(0,0,100); this.input.targetPosition.copy(this.dolly.position);
                this.world.buildTurrell(this.camera); this.world.build(); this.world.buildGhost();
                window.addEventListener('resize', () => { this.camera.aspect = window.innerWidth / window.innerHeight; this.camera.updateProjectionMatrix(); this.renderer.setSize(window.innerWidth, window.innerHeight); });
                this.renderer.setAnimationLoop(this.render.bind(this));
            }
            triggerAttention(camera, structures) { const frustum = new THREE.Frustum(); const projScreenMatrix = new THREE.Matrix4(); projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse); frustum.setFromProjectionMatrix(projScreenMatrix); let candidates = []; structures.forEach(child => { if (child.isMesh && frustum.containsPoint(child.position)) { const dist = child.position.distanceTo(camera.position); if (dist > 10 && dist < 150) candidates.push({ mesh: child, dist: dist }); } }); candidates.sort((a, b) => a.dist - b.dist); const top5 = candidates.slice(0, 5); if (top5.length > 0) { this.activeMesh = top5[Math.floor(Math.random() * top5.length)].mesh; this.attentionInfluence = 0; } }
            render() {
                const now = (Date.now() - startTime) / 1000; const dt = 1/60; 
                const inputAmt = this.input.getAndResetInput();
                const currentState = this.stateManager.update(dt, inputAmt);
                const chaosLevel = this.stateManager.chaosLevel;
                let audioChaosParameter = 0; const breathPhaseDuration = CONFIG.timing.totalCycles * FULL_CYCLE_DURATION; 
                if (currentState === 'ACTIVE' || currentState === 'RECOVERING') { audioChaosParameter = chaosLevel; } else if (currentState === 'PASSIVE') { const timeInPassive = now - this.passiveStartTime; if (timeInPassive < breathPhaseDuration) { const progress = timeInPassive / breathPhaseDuration; audioChaosParameter = -(progress * 0.5); } else { const voidTime = timeInPassive - breathPhaseDuration; const voidProgress = Math.min(voidTime / 20.0, 1.0); audioChaosParameter = -0.5 - (voidProgress * 0.5); } }
                this.soundManager.update(audioChaosParameter);
                let targets = { drift: 0, vacuum: 0, agnosia: 0, heavyBlur: 0, emissive: 0, blur: 0, attention: 0, turrellOpacity: 0 };
                if (currentState === 'PASSIVE') { if (this.passiveStartTime === 0) this.passiveStartTime = now; targets = this.breathSystem.update(now - this.passiveStartTime, this.camera, this.world, { trigger: this.triggerAttention.bind(this), activeMesh: this.activeMesh }); } else { this.passiveStartTime = 0; this.breathSystem.reset(); this.activeMesh = null; if (currentState === 'WAKING') { targets.vacuum = -0.05; targets.drift = 0.05; } else if (currentState === 'ACTIVE' || currentState === 'RECOVERING') { targets.drift = 0; } else { targets.drift = 0.03; } }
                this.currentDriftSpeed += (targets.drift - this.currentDriftSpeed) * CONFIG.physics.acceleration; this.currentVacuumSpeed += (targets.vacuum - this.currentVacuumSpeed) * CONFIG.physics.acceleration; this.currentAgnosia += (targets.agnosia - this.currentAgnosia) * 0.05; this.currentHeavyBlur += (targets.heavyBlur - this.currentHeavyBlur) * 0.05; this.attentionInfluence += (targets.attention - this.attentionInfluence) * 0.05;
                this.world.structures.forEach((mesh) => { if (Math.abs(this.currentDriftSpeed) > 0.001 && mesh.userData.driftVec) mesh.position.addScaledVector(mesh.userData.driftVec, this.currentDriftSpeed); if (Math.abs(this.currentVacuumSpeed) > 0.0001) { const pushDir = mesh.position.clone().normalize(); if (pushDir.lengthSq() < 0.001) pushDir.set(0, 0, 1); mesh.position.addScaledVector(pushDir, this.currentVacuumSpeed); } if (this.accumulatedScatter > 0.001 && mesh.userData.originalPos) { mesh.position.addScaledVector(mesh.userData.driftVec, this.accumulatedScatter * 0.1); } let activeMove = new THREE.Vector3(0,0,0); if ((currentState === 'ACTIVE' || currentState === 'RECOVERING') && chaosLevel > 0) { const personalThreshold = 0.3 + (mesh.id % 30) * 0.01; if (chaosLevel > personalThreshold) { let lookIntensity = Math.min((chaosLevel - personalThreshold) / 0.2, 1.0); const dummy = new THREE.Object3D(); dummy.position.copy(mesh.position); dummy.lookAt(this.dolly.position); mesh.quaternion.slerp(dummy.quaternion, 0.03 * lookIntensity); } else { mesh.quaternion.slerp(mesh.userData.originalRot, 0.05); } if (chaosLevel > 0.61) { const swarmIntensity = (chaosLevel - 0.61) / 0.39; const speed = swarmIntensity * CONFIG.chaos.maxAttackSpeed * 2.0; let swarmDir = mesh.userData.driftVec.clone(); swarmDir.x += Math.sin(now * 2.0 + mesh.id) * 0.5; swarmDir.y += Math.cos(now * 1.5 + mesh.id) * 0.5; swarmDir.normalize(); const vecToCam = new THREE.Vector3().subVectors(this.dolly.position, mesh.position).normalize(); swarmDir.addScaledVector(vecToCam, 0.2).normalize(); activeMove = swarmDir.multiplyScalar(speed); const dist = mesh.position.distanceTo(this.dolly.position); if (dist > CONFIG.world.size * 1.2) { const respawnPos = new THREE.Vector3((Math.random()-0.5)*CONFIG.world.size, (Math.random()-0.5)*CONFIG.world.size, (Math.random()-0.5)*CONFIG.world.size); mesh.position.copy(this.dolly.position).add(respawnPos); } } } else if (currentState === 'NEUTRAL') { mesh.quaternion.slerp(mesh.userData.originalRot, 0.02); } mesh.position.add(activeMove); if (mesh.userData.targetEffectFactor !== undefined) { let factor = mesh.material.uniforms.uEffectFactor.value; if (factor < mesh.userData.targetEffectFactor) { factor += CONFIG.effects.transitionSpeed; if (factor > mesh.userData.targetEffectFactor) factor = mesh.userData.targetEffectFactor; } mesh.material.uniforms.uEffectFactor.value = factor; } if (mesh.material.uniforms) { if (mesh.material.uniforms.cameraPos) { mesh.material.uniforms.cameraPos.value.copy(this.dolly.position); } mesh.material.uniforms.uEmissiveStrength.value = targets.emissive; mesh.material.uniforms.uBlurStrength.value = targets.blur; mesh.material.uniforms.uAgnosiaStrength.value = this.currentAgnosia; mesh.material.uniforms.uHeavyBlur.value = this.currentHeavyBlur; mesh.material.uniforms.uTime.value = now; } });
                if (chaosLevel < 0.3) { const b = CONFIG.world.size * 0.5; this.world.structures.forEach(s => { if (s.position.x - this.dolly.position.x > b) s.position.x -= b * 2; if (s.position.x - this.dolly.position.x < -b) s.position.x += b * 2; if (s.position.y - this.dolly.position.y > b) s.position.y -= b * 2; if (s.position.y - this.dolly.position.y < -b) s.position.y += b * 2; if (s.position.z - this.dolly.position.z > b) s.position.z -= b * 2; if (s.position.z - this.dolly.position.z < -b) s.position.z += b * 2; }); }
                this.input.updateCamera(chaosLevel, now, currentState, timeInPassive);
                if (this.breathSystem.ghostActive && this.world.ghostPlane) { const progress = (now - this.breathSystem.ghostStartTime) / CONFIG.timing.ghostDuration; if (progress < 1.0) { this.world.ghostPlane.position.lerpVectors(this.breathSystem.ghostStartPos, this.breathSystem.ghostEndPos, progress); this.world.ghostPlane.position.addScaledVector(this.camera.up, Math.sin(progress * Math.PI * 4) * 2); } else { this.world.ghostPlane.visible = false; this.breathSystem.ghostActive = false; } }
                if (this.world.turrellPlane) { let targetOpacity = (currentState === 'PASSIVE') ? targets.turrellOpacity : 0.0; this.world.turrellPlane.material.uniforms.uOpacity.value += (targetOpacity - this.world.turrellPlane.material.uniforms.uOpacity.value) * 0.05; this.world.turrellPlane.material.uniforms.uTime.value = now; }
                if (this.activeMesh && this.attentionInfluence > 0.001) { const meshWorldPos = new THREE.Vector3(); this.activeMesh.getWorldPosition(meshWorldPos); this.dummyObj.position.copy(meshWorldPos); this.dummyObj.lookAt(this.dolly.position); const targetLocalQuat = this.dummyObj.quaternion.clone(); if (this.activeMesh.parent) { const parentWorldQuat = new THREE.Quaternion(); this.activeMesh.parent.getWorldQuaternion(parentWorldQuat); const parentInv = parentWorldQuat.clone().invert(); targetLocalQuat.premultiply(parentInv); const moveDir = new THREE.Vector3().subVectors(this.dolly.position, meshWorldPos).normalize(); moveDir.applyQuaternion(parentInv); this.activeMesh.position.addScaledVector(moveDir, 0.04); } else { const moveDir = new THREE.Vector3().subVectors(this.dolly.position, meshWorldPos).normalize(); this.activeMesh.position.addScaledVector(moveDir, 0.04); } this.activeMesh.quaternion.slerp(targetLocalQuat, 0.02); }
                this.renderer.render(this.scene, this.camera);
            }
        }
        new App();
    </script>
</body>
</html>
